# C++面试题学习笔记

## 语法

### sizeof字节数
#### 空struct和空class
sizeof(Empty) = 1。  

#### 32位64位
最大区别是32位指针大小为4byte，而64位的指针大小为8byte。  
[C++ 32位64位的区别](https://blog.csdn.net/crystal_lpx/article/details/71600721)  

#### 字节对齐

**准则**  
字节对齐的细节和具体编译器实现相关，但一般而言，满足三个准则：
1) 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；
2) 结构体每个成员相对于结构体首地址的偏移量都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节；
3) 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。

例子：
```C++
struct Test
{
    int a;
    char b;
    double c[10];
    char d;
};
```
1. 如果只有a，那么是4。  
2. 如果只有a和b，那么应用第3条，会在b后面填充字节，所以是4 + 1 + (3)。
3. 如果只有a和c，那么应用第2条，会在c前面填充，所以是4 + (4) + 80。
4. 如果只有b和c，同上，1 + (7) + 80。
4. 如果abcd，那么应用第3条，会在c后面填充字节，所以是4 + 1 + (3) + 80 + 1 + (7)。  

所以sizeof(Test) = 96  

#### 位域字节对齐
使用位域的主要目的是压缩存储，其大致规则为：
1) 如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字
段将紧邻前一个字段存储，直到不能容纳为止；
2) 如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字
段将从新的存储单元开始，其偏移量为其类型大小的整数倍；
3) 如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方
式，Dev-C++采取压缩方式；
4) 如果位域字段之间穿插着非位域字段，则不进行压缩；
5) 整个结构体的总大小为最宽基本类型成员大小的整数倍。

例子：  
```C++
struct Test_bit
{
	int a : 8;
	int b : 8;
	int c : 8;
	char f;
	int d : 8;
	int e : 8;
	char g;
};

```
1. int，4个字节，32位。
2. 如果只有abcd，那么是4。
3. 如果abcde，那么超过了32位，所以是4 + 4。
4. 如果abc f de，因为f是不同类型，所以是4 + 1 + (3) + 4。
5. 如果是abc f de g，同上，所以是4 + 1 + (3) + 4 + 1 + (3)。  

所以sizeof(Test_bit) = 16

#### sizeof(shared_ptr)
由于control_block的存在，shared_ptr的size通常是2倍裸指针或unique_ptr的大小，此外，shared_ptr的引用计数增减是原子操作。

### Functor 伪函数
```C++
// 一段代码，说一下运行结果
class A {
public: 
    void f1() {}
    virtual void f2() {}
};

int main()
{
	A* a = nullptr;
	a->f1();
	a->f2();
}
```

### 对象指针为NULL，为什么还是可以调用成员函数
```C++
// 一段代码，说一下运行结果
class A {
public: 
    void f1() {}
    virtual void f2() {}
};

int main()
{
	A* a = nullptr;
	a->f1();
	a->f2();
}
```

类的成员函数并不与具体对象绑定，所有的对象共用同一份成员函数体。  

当程序被编译后，成员函数的地址即已确定，这份共有的成员函数体之所以能够把不同对象的数据区分开来，靠的是隐式传递给成员函数的this指针，成员函数中对成员变量的访问都是转化成"this->数据成员"的方式。  

因此，从这一角度说，成员函数与普通函数一样，只是多了一个隐式参数，即指向对象的this指针。  

而类的静态成员函数只能访问静态成员变量，不能访问非静态成员变量，所以静态成员函数不需要指向对象的this指针作为隐式参数。  

[详细](https://blog.csdn.net/chenzrcd/article/details/60472616)

## 知识

### C++三大特性
封装，继承，多态  
封装可以隐藏实现细节，使得代码模块化，继承可以扩展已存在的模块，它们目的都是为了：代码重用。而多态是为了实现另一个目的：接口重用。

[详细](https://blog.csdn.net/doo66/article/details/52208922)

### C++中的动态类型与动态绑定、虚函数、运行时多态的实现
静态绑定：编译时绑定，通过对象调用  
动态绑定：运行时绑定，通过地址实现  
[详细](https://blog.csdn.net/iicy266/article/details/11906509)
